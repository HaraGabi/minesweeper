{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/game.ts","webpack:///./src/index.ts","webpack:///./src/renderer.ts","webpack:///./src/minesweeperLayout.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","marked","UnknownCell","mineCount","OpenCell","ExplodedCell","width","height","this","remainingToOpen","gameConclusion","stateMap","Array","y","mineMap","getCellAt","x","state","contents","tryToggleMark","undefined","tryOpen","initializeMines","explode","openKnownGoodCell","openSurroundingIfSatisfied","cell","surroundingCoords","getSurroundingCoordinates","openable","markCount","length","coords","push","guaranteedCell","fill","plantedCount","Math","floor","random","abs","allSurrounding","surrounding","console","log","knownGoodCells","pop","concat","coordinates","Game","game","Renderer","document","getElementById","minefieldContainer","mouseDownCell","isMouseCaptured","canvas","createElement","context","getContext","appendChild","window","addEventListener","refreshCanvasLayout","ev","onMouseDown","onMouseMove","onMouseUp","onDoubleClick","preventDefault","devicePixelRatio","devicePixelWidth","clientWidth","devicePixelHeight","clientHeight","layout","renderSize","MinesweeperLayout","style","render","conclusion","button","updateMouseDownCell","getCellByMouseLocation","areSame","first","second","getCellCoordinatesByMouseLocation","offsetX","offsetY","minefieldBounds","cellSize","clearRect","fillStyle","fillRect","strokeStyle","pixelY","getCellBorderY","beginPath","moveTo","lineTo","stroke","pixelX","getCellBorderX","font","drawCell","getCellBounds","cellBounds","isMouseDown","borderSize","right","bottom","closePath","text","toString","drawCenteredText","bounds","metrics","measureText","textBaseline","fillText","renderWidth","renderHeight","gameWidth","gameHeight","gameSize","outerBounds","aspect","fitRectangle","mouseLocation","cellX","cellY","correctedHeight","correctedWidth"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","export class UnknownCell {\n    constructor(readonly marked: boolean) {\n    }\n}\n\nexport class OpenCell {\n    constructor(readonly mineCount: number) {\n    }\n}\n\nexport class ExplodedCell { }\n\nexport type CellCoords = { x: number, y: number };\n\nexport class Game {\n    private stateMap: (undefined | 'marked' | 'revealed')[][];\n    private mineMap: ('bomb' | number)[][] | null;\n    private remainingToOpen: number;\n    private gameConclusion: (null | 'win' | 'loss');\n\n    constructor(readonly width: number, readonly height: number, readonly mineCount: number) {\n        this.remainingToOpen = width * height - mineCount;\n        this.gameConclusion = null;\n\n        this.stateMap = new Array(height);\n        for (let y = 0; y < height; y++)\n            this.stateMap[y] = new Array(width);\n\n        this.mineMap = null;\n    }\n\n    get conclusion() { return this.gameConclusion; }\n\n    getCellAt(x: number, y: number) {\n        const state = this.stateMap[y][x];\n\n        if (state !== 'revealed')\n            return new UnknownCell(state === 'marked');\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n        return contents === 'bomb' ? new ExplodedCell() : new OpenCell(contents);\n    }\n\n    tryToggleMark(x: number, y: number) {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed') return false;\n\n        this.stateMap[y][x] = state === 'marked' ? undefined : 'marked';\n        return true;\n    }\n\n    tryOpen(x: number, y: number) {\n        const state = this.stateMap[y][x];\n        if (state === 'revealed' || state === 'marked') return false;\n\n        if (this.mineMap === null)\n            this.initializeMines({ x, y });\n\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n        const contents = this.mineMap[y][x];\n\n        if (contents === 'bomb')\n            this.explode();\n        else\n            this.openKnownGoodCell(x, y);\n\n        return true;\n    }\n\n    openSurroundingIfSatisfied(x: number, y: number) {\n        const cell = this.getCellAt(x, y);\n\n        if (cell instanceof OpenCell) {\n            const surroundingCoords = this.getSurroundingCoordinates(x, y);\n\n            let openable = new Array<CellCoords>();\n            let markCount = 0;\n\n            for (let i = 0; i < surroundingCoords.length; i++) {\n                const coords = surroundingCoords[i];\n                const state = this.stateMap[coords.y][coords.x];\n\n                if (state === 'marked') {\n                    markCount++;\n                } else if (state !== 'revealed') {\n                    openable.push(coords);\n                }\n            }\n\n            if (markCount === cell.mineCount) {\n                for (let i = 0; i < openable.length; i++) {\n                    const coords = openable[i];\n                    this.tryOpen(coords.x, coords.y);\n                    if (this.gameConclusion) break;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private initializeMines(guaranteedCell: CellCoords) {\n        this.mineMap = new Array(this.height);\n        for (let y = 0; y < this.height; y++)\n            this.mineMap[y] = (new Array(this.width) as any).fill(0);\n\n        for (let plantedCount = 0; plantedCount < this.mineCount;) {\n            const x = Math.floor(Math.random() * this.width);\n            const y = Math.floor(Math.random() * this.height);\n\n            if (Math.abs(x - guaranteedCell.x) <= 1 && Math.abs(y - guaranteedCell.y) <= 1) continue;\n            if (this.mineMap[y][x] === 'bomb') continue;\n\n            this.mineMap[y][x] = 'bomb';\n\n            const allSurrounding = this.getSurroundingCoordinates(x, y);\n            for (let i = 0; i < allSurrounding.length; i++) {\n                const surrounding = allSurrounding[i];\n                const contents = this.mineMap[surrounding.y][surrounding.x];\n                if (contents !== 'bomb')\n                    this.mineMap[surrounding.y][surrounding.x] = contents + 1;\n            }\n\n            plantedCount++;\n        }\n\n        console.log(this.mineMap);\n    }\n\n    private explode() {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        this.gameConclusion = 'loss';\n\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                if (this.mineMap[y][x] === 'bomb') {\n                    this.stateMap[y][x] = 'revealed';\n                }\n            }\n        }\n    }\n\n    private openKnownGoodCell(x: number, y: number) {\n        if (!this.mineMap) throw 'mineMap should be initialized before any cell state is revealed.';\n\n        let knownGoodCells = [{ x, y }];\n\n        while (true) {\n            const cell = knownGoodCells.pop();\n            if (!cell) break;\n\n            const state = this.stateMap[cell.y][cell.x];\n            if (state === 'marked' || state === 'revealed') continue;\n\n            this.stateMap[cell.y][cell.x] = 'revealed';\n\n            this.remainingToOpen--;\n            if (this.remainingToOpen === 0) {\n                this.gameConclusion = 'win';\n                break;\n            }\n\n            if (this.mineMap[cell.y][cell.x] === 0)\n                knownGoodCells = knownGoodCells.concat(this.getSurroundingCoordinates(cell.x, cell.y));\n        }\n    }\n\n    private getSurroundingCoordinates(x: number, y: number) {\n        const coordinates = new Array<CellCoords>();\n\n        if (y > 0)\n            coordinates.push({ x, y: y - 1 });\n        if (y < this.height - 1)\n            coordinates.push({ x, y: y + 1 });\n\n        if (x > 0)\n        {\n            coordinates.push({ x: x - 1, y });\n            if (y > 0)\n                coordinates.push({ x: x - 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x - 1, y: y + 1 });\n        }\n\n        if (x < this.width - 1) {\n            coordinates.push({ x: x + 1, y });\n            if (y > 0)\n                coordinates.push({ x: x + 1, y: y - 1 });\n            if (y < this.height - 1)\n                coordinates.push({ x: x + 1, y: y + 1 });\n        }\n\n        return coordinates;\n    }\n}\n","import { Game } from './game';\nimport { Renderer } from './renderer';\n\nconst game = new Game(30, 16, 99);\n\nnew Renderer(game, document.getElementById('minefield-container')!);\n","import { Game, UnknownCell, OpenCell, CellCoords } from './game';\nimport { MinesweeperLayout, Rectangle } from './minesweeperLayout';\n\nexport class Renderer {\n    private readonly game: Game;\n    private readonly minefieldContainer: HTMLElement;\n    private readonly context: CanvasRenderingContext2D;\n    private layout!: MinesweeperLayout;\n    private mouseDownCell: CellCoords | null = null;\n    private isMouseCaptured: boolean = false;\n\n    constructor(game: Game, minefieldContainer: HTMLElement) {\n        this.game = game;\n\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!context) throw 'Unable to obtain a 2D drawing context.';\n        this.context = context;\n\n        this.minefieldContainer = minefieldContainer;\n        minefieldContainer.appendChild(canvas);\n\n        window.addEventListener('resize', () => this.refreshCanvasLayout());\n        this.refreshCanvasLayout();\n\n        canvas.addEventListener('mousedown', ev => this.onMouseDown(ev));\n        canvas.addEventListener('mousemove', ev => this.onMouseMove(ev));\n        canvas.addEventListener('mouseup', ev => this.onMouseUp(ev));\n        canvas.addEventListener('dblclick', ev => this.onDoubleClick(ev));\n        window.addEventListener('contextmenu', ev => ev.preventDefault(), false);\n    }\n\n    private refreshCanvasLayout() {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const devicePixelWidth = this.minefieldContainer.clientWidth * devicePixelRatio;\n        const devicePixelHeight = this.minefieldContainer.clientHeight * devicePixelRatio;\n\n        if (this.layout\n            && this.layout.renderSize.width === devicePixelWidth\n            && this.layout.renderSize.height === devicePixelHeight) {\n\n            return;\n        }\n\n        this.layout = new MinesweeperLayout(devicePixelWidth, devicePixelHeight, this.game.width, this.game.height);\n        const canvas = this.context.canvas;\n        canvas.style.width = this.minefieldContainer.clientWidth + 'px';\n        canvas.style.height = this.minefieldContainer.clientHeight + 'px';\n        canvas.width = devicePixelWidth;\n        canvas.height = devicePixelHeight;\n        this.render();\n    }\n\n    private onMouseDown(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            this.isMouseCaptured = true;\n            this.updateMouseDownCell(ev);\n        } else if (ev.button === 2) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.tryToggleMark(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private onMouseMove(ev: MouseEvent) {\n        if (this.isMouseCaptured)\n            this.updateMouseDownCell(ev);\n    }\n\n    private onMouseUp(ev: MouseEvent) {\n        if (ev.button === 0) {\n            this.isMouseCaptured = false;\n\n            if (this.mouseDownCell) {\n                this.game.tryOpen(this.mouseDownCell.x, this.mouseDownCell.y);\n                this.mouseDownCell = null;\n                this.render();\n            }\n        }\n    }\n\n    private onDoubleClick(ev: MouseEvent) {\n        if (this.game.conclusion) return;\n\n        if (ev.button === 0) {\n            const coords = this.getCellByMouseLocation(ev);\n\n            if (coords && this.game.openSurroundingIfSatisfied(coords.x, coords.y))\n                this.render();\n        }\n    }\n\n    private updateMouseDownCell(ev: MouseEvent) {\n        const coords = this.getCellByMouseLocation(ev);\n\n        if (!Renderer.areSame(coords, this.mouseDownCell)) {\n            this.mouseDownCell = coords;\n            this.render();\n        }\n    }\n\n    private static areSame(first: CellCoords | null, second: CellCoords | null) {\n        if (!first) return !second;\n        if (!second) return false;\n        return first.x === second.x && first.y === second.y;\n    }\n\n    private getCellByMouseLocation(ev: MouseEvent) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n\n        return this.layout.getCellCoordinatesByMouseLocation({\n            x: ev.offsetX * devicePixelRatio,\n            y: ev.offsetY * devicePixelRatio\n        });\n    }\n\n    render() {\n        const { renderSize, minefieldBounds, cellSize } = this.layout;\n\n        this.context.clearRect(0, 0, renderSize.width, renderSize.height);\n\n        this.context.fillStyle = '#d0d0d0';\n        this.context.fillRect(minefieldBounds.x, minefieldBounds.y, minefieldBounds.width, minefieldBounds.height);\n\n        this.context.strokeStyle = '#a0a0a0';\n\n        for (let y = 0; y < this.game.height; y++) {\n            const pixelY = this.layout.getCellBorderY(y);\n            this.context.beginPath();\n            this.context.moveTo(minefieldBounds.x, pixelY);\n            this.context.lineTo(minefieldBounds.x + minefieldBounds.width, pixelY);\n            this.context.stroke();\n        }\n\n        for (let x = 0; x < this.game.width; x++) {\n            const pixelX = this.layout.getCellBorderX(x);\n            this.context.beginPath();\n            this.context.moveTo(pixelX, minefieldBounds.y);\n            this.context.lineTo(pixelX, minefieldBounds.y + minefieldBounds.height);\n            this.context.stroke();\n        }\n\n        this.context.font = 'bold ' + (cellSize * 0.5) + 'px Georgia';\n\n        for (let y = 0; y < this.game.height; y++) {\n            for (let x = 0; x < this.game.width; x++) {\n                this.drawCell({ x, y }, this.layout.getCellBounds(x, y), cellSize);\n            }\n        }\n    }\n\n    private drawCell(coords: CellCoords, cellBounds: Rectangle, cellSize: number) {\n        const { x, y } = coords;\n\n        const isMouseDown = this.mouseDownCell && this.mouseDownCell.x === x && this.mouseDownCell.y === y;\n\n        const cell = this.game.getCellAt(x, y);\n\n        if (cell instanceof UnknownCell && (cell.marked || !isMouseDown)) {\n            const borderSize = cellSize * 0.1;\n\n            const right = cellBounds.x + cellBounds.width;\n            const bottom = cellBounds.y + cellBounds.height;\n\n            this.context.beginPath();\n            this.context.moveTo(cellBounds.x, cellBounds.y);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.closePath();\n            this.context.fillStyle = '#e8e8e8';\n            this.context.fill();\n\n            this.context.beginPath();\n            this.context.moveTo(right, bottom);\n            this.context.lineTo(right, cellBounds.y);\n            this.context.lineTo(right - borderSize, cellBounds.y + borderSize);\n            this.context.lineTo(right - borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x + borderSize, bottom - borderSize);\n            this.context.lineTo(cellBounds.x, bottom);\n            this.context.closePath();\n            this.context.fillStyle = '#a0a0a0';\n            this.context.fill();\n        }\n\n        const text =\n            cell instanceof UnknownCell ? (cell.marked ? '🚩' : null) :\n            cell instanceof OpenCell ? (cell.mineCount !== 0 ? cell.mineCount.toString() : null) :\n            '💥';\n\n        if (text !== null) {\n            if (cell instanceof OpenCell)\n                this.context.fillStyle = ['blue', 'green', '#e00', 'darkblue', 'brown', 'darkcyan', 'black', 'gray'][cell.mineCount - 1];\n\n            this.drawCenteredText(text, cellBounds);\n        }\n    }\n\n    private drawCenteredText(text: string, bounds: Rectangle) {\n        var metrics = this.context.measureText(text);\n        this.context.textBaseline = 'middle';\n        this.context.fillText(text, bounds.x + (bounds.width - metrics.width) / 2, bounds.y + bounds.height / 2);\n    }\n}\n","export type Rectangle = { x: number, y: number, width: number, height: number };\n\nexport class MinesweeperLayout {\n    readonly renderSize: { width: number, height: number };\n    readonly gameSize: { width: number, height: number };\n    readonly cellSize: number;\n    readonly minefieldBounds: Rectangle;\n\n    constructor(renderWidth: number, renderHeight: number, gameWidth: number, gameHeight: number) {\n        this.renderSize = { width: renderWidth, height: renderHeight };\n        this.gameSize = { width: gameWidth, height: gameHeight };\n\n        const outerBounds = { x: 0, y: 0, width: this.renderSize.width, height: this.renderSize.height };\n        const aspect = { width: gameWidth, height: gameHeight };\n        this.minefieldBounds = MinesweeperLayout.fitRectangle(aspect, outerBounds);\n\n        this.cellSize = this.minefieldBounds.width / gameWidth;\n    }\n\n    getCellCoordinatesByMouseLocation(mouseLocation: { x: number, y: number }) {\n        const x = Math.floor((mouseLocation.x - this.minefieldBounds.x) / this.cellSize);\n        if (x < 0 || x >= this.gameSize.width) return null;\n\n        const y = Math.floor((mouseLocation.y - this.minefieldBounds.y) / this.cellSize);\n        if (y < 0 || y >= this.gameSize.height) return null;\n\n        return { x, y };\n    }\n\n    getCellBorderX(cellX: number) {\n        return Math.floor(this.minefieldBounds.x + this.cellSize * cellX);\n    }\n\n    getCellBorderY(cellY: number) {\n        return Math.floor(this.minefieldBounds.y + this.cellSize * cellY);\n    }\n\n    getCellBounds(cellX: number, cellY: number) {\n        const x = this.getCellBorderX(cellX);\n        const y = this.getCellBorderY(cellY);\n\n        return {\n            x,\n            y,\n            width: this.getCellBorderX(cellX + 1) - x,\n            height: this.getCellBorderY(cellY + 1) - y\n        };\n    }\n\n    private static fitRectangle(aspect: { width: number, height: number }, outerBounds: Rectangle) {\n        if (outerBounds.width * aspect.height < outerBounds.height * aspect.width) {\n            var correctedHeight = outerBounds.width * aspect.height / aspect.width;\n\n            return {\n                x: 0,\n                y: (outerBounds.height - correctedHeight) / 2,\n                width: outerBounds.width,\n                height: correctedHeight\n            };\n        } else {\n            var correctedWidth = outerBounds.height * aspect.width / aspect.height;\n\n            return {\n                x: (outerBounds.width - correctedWidth) / 2,\n                y: 0,\n                width: correctedWidth,\n                height: outerBounds.height\n            };\n        }\n    }\n}\n"],"sourceRoot":""}